/*##ExcludeFromDocumentation##*/

/*** HELP START ***//* 
Internal utility macros for package documentation

Provides core functionality for the sasdocs package.
These macros handle metadata extraction and file collection operations.

### Macros

**`%_getPackagemeta`**
- Extracts package metadata from `description.sas` file
- Reads package name, version, author, maintainer, title, encoding, license, and dependency information

**`%_collectFilesWithCodes`**
- Collects all files with code from package source location
- Scans the package directory structure and identifies files containing SAS code for documentation

**`%_generateWorkflows`**
- Generates GitHub Actions workflow file for automatic documentation deployment

*//*** HELP END ***/

%macro _getPackagemeta(targetPath=) ;
  %local device _PackageFileref_ ;

  %if %sysfunc(prxmatch(/\.zip$/i, &targetPath.)) > 0 %then
    %let device = zip ;
  ;

  %let _PackageFileref_ = _%sysfunc(datetime(), hex6.)_ ;

  filename &_PackageFileref_. &device. "&targetPath." ;   
  filename &_PackageFileref_. list;
  
  %if %superq(device) eq %then
    %do ;
      %if %sysfunc(fileexist(&targetPath./description.sas)) = 0 %then
        %do ;
          %put ERROR: The targetPath: &targetPath. should point to a ZIP file or a folder with description.sas.;
          %abort;
        %end ;
    %end ;
 
    data _null_;
      infile &_PackageFileref_.(description.sas);
      input;
      metaExtStr=kscanx(_INFILE_, 2, ":");
      select( strip(upcase(kscanx(_INFILE_, 1, ":"))) );
        when("PACKAGE")     call symputX("packageName",        metaExtStr);
        when("VERSION")     call symputX("packageVersion",     metaExtStr);
        when("AUTHOR")      call symputX("packageAuthor",      metaExtStr);
        when("MAINTAINER")  call symputX("packageMaintainer",  metaExtStr);
        when("TITLE")       call symputX("packageTitle",       metaExtStr);
        when("ENCODING")    call symputX("packageEncoding",    metaExtStr);
        when("LICENSE")     call symputX("packageLicense",     metaExtStr);
        when("REQUIRED")    call symputX("packageRequired",    metaExtStr);
        when("REQPACKAGES") call symputX("packageReqPackages", metaExtStr);
        otherwise ;
      end;
    run ;

  %if %superq(device) = zip %then
    %do ;
      data _null_;
        infile &_PackageFileref_.(help.sas);
        input;
        if find(_infile_, '%put NOTE- Generated:') then 
          do;
            pkgGen = prxchange('s/.*Generated: (.+);/$1/i', -1, _infile_);
            call symputX("packageGenerated", strip(pkgGen));
          end;
        /* extract SPF, OS, and SAS versions */
        if find(_infile_, "SAS package generated by SAS Package Framework, version") then 
          do ;
            spfVersion = prxchange('s/.*version `([0-9]+)`.*/$1/i', -1, _infile_);
            call symputX("pkgSPFVer", spfVersion);
            input ;
            OSVer = prxchange('s/.*under (.+) operating system.*/$1/i', -1, _infile_);
            call symputX("pkgOSVer", OSVer);
            input ;
            SASVer = prxchange('s/.*using SAS release: `([^`]+)`.*/$1/i', -1, _infile_);
            call symputX("pkgSASVer", SASVer);
            stop;
          end;
      run ;

      filename &_PackageFileref_. "&targetPath." ;
      
      data _null_;
        set sashelp.vfunc(keep=fncname);
        where fncname = "HASHING_FILE";
        call execute('
        data work.the_SHA256_hash_id;' ||
            /* F - file */
            " SHA256 = 'F*' !! HASHING_FILE('SHA256', pathname('&_PackageFileref_.','F'), 0); " ||
            ' TYPE="F"; ' ||
            ' put / @7 SHA256= / " "; output; ' ||
            ' call symputX("packageHashF",SHA256);' ||
            /* C  - content */
            " SHA256 = 'C*' !! HASHING_FILE('SHA256', '&_PackageFileref_.', 4); " ||
            ' TYPE="C"; ' ||
            ' put / @7 SHA256= / " "; output; ' ||
            ' call symputX("packageHashC",SHA256);' ||
            ' label ' ||
            '  SHA256 = "The SHA256 hash digest for package &packageName.:" ' ||
            '  TYPE= "Type of hash digest / F = file / C = content"; ' ||
        'run;');
        call execute('proc print data = work.the_SHA256_hash_id noobs label split="/"; run;');
        stop;
      run;
    %end; 
    
    filename &_PackageFileref_. clear;
%mend _getPackagemeta;

/* ------------------------------------------------------------------------------------ */

%macro _collectFilesWithCodes(filesLocation  =
                            , filesWithCodes = 
                            );  

  %collectFiles(targetLocation=&filesLocation., maxDepth=2, listDataSet=&filesWithCodes.);

  /* if target is a zip file, need to modify dataset */
  %if %sysfunc(prxmatch(/\.zip$/i, &filesLocation.)) > 0 %then
    %do ;
      data &filesWithCodes.;
        set &filesWithCodes.;
        where depth = 1 ;
        if substr(name, 1, 1) = "_" then 
        do;
          fileshort = prxchange('s/^_(.+?)\.(.+)\..*/$2/', -1, strip(name));
          folder = prxchange('s/^_(.+?)\.(.+)/$1/', -1, strip(name));
        end ;
        if name = "addcnt.zip" then folder = "addcnt" ;
        depth = 2 ;
        if missing(folder) then delete ;
      run;
    %end;

  proc sort data=&filesWithCodes.;
    by folder name ;
  run;

  /* collect the data */
    %put NOTE- ;
    %put NOTE: Generating content dataset: &filesWithCodes..;
    %put NOTE- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^;
    %put NOTE- ;

    data &filesWithCodes.;
      set &filesWithCodes.;
    by folder ;
    where depth = 2 ;
    
    drop lowcase_name;
    length type $200 ;

    order = kscanx(folder, 1, "_");
    type  = kscanx(folder,-1, "_");
    file = name;
    
      type2=type;
      length link $ 256;
      link=catx("-",compress(fileshort,,"KAD"),type,_n_);
      length fileshort2 $ 256;
      select;
        when (upcase(type) =:  "MACRO"    ) do; fileshort2 = cats('`%', fileshort, "()`"); type2='macro';           end;
        when (upcase(type) =:  "FORMAT"   ) do; fileshort2 = cats("`$", fileshort, ".`");  type2='format/informat'; end;
        when (upcase(type) =:  "FUNCTION" ) do; fileshort2 = cats("`",  fileshort, "()`"); type2='function';        end; 
        when (upcase(type) =:  "IMLMODULE") fileshort2 = cats("`", fileshort, "()`");
        when (upcase(type) =:  "PROTO"    ) fileshort2 = cats("`", fileshort, "()`");
        when (upcase(type) =:  "CASLUDF"  ) fileshort2 = cats("`", fileshort, "()`");
        otherwise                           fileshort2 = cats("`", fileshort, "`");
      end;

    select;
        when (upcase(type) =:  "LIBNAME"  ) type_order = 1;
        when (upcase(type) =:  "MACRO"    ) type_order = 2;
        when (upcase(type) =:  "FUNCTION" ) type_order = 3;
        when (upcase(type) =:  "FORMAT"   ) type_order = 4;
        when (upcase(type) =:  "IMLMODULE") type_order = 5;
        when (upcase(type) =:  "PROTO"    ) type_order = 6;
        when (upcase(type) =:  "EXEC"     ) type_order = 7;
        when (upcase(type) =:  "CLEAN"    ) type_order = 8;
        when (upcase(type) =:  "LAZYDATA" ) type_order = 9;    
        when (upcase(type) =:  "TEST"     ) type_order = 10;
        when (upcase(type) =:  "CASLUDF"  ) type_order = 11;
        when (upcase(type) =:  "ADDCNT"   ) type_order = 12;
        when (upcase(type) =:  "KMFSNIP"  ) type_order = 13;
        when (upcase(type) =:  "DS2PCK"   ) type_order = 14;
        when (upcase(type) =:  "DS2THR"   ) type_order = 15;
        otherwise                           type_order = 99;
      end;

    group = put(coalesce(input(order,?? best.), type_order), z3.);

    /* ignore folders which name starts with ! */
    if "!" =: folder then
      do;
        if first.folder = 1 then 
          do;
            put "INFO: Folder " folder "name starts with ! and will be ignored. " /
                "      No content from it will be used to generate the package." / " ";
          end;
        delete;
      end;

    if folder NE lowcase(folder) then
      do;
        if first.folder = 1 then 
          do;
            put 'ERROR: Folder should be named ONLY with low case letters.';
            put 'ERROR- Current value is: ' folder;
            lowcase_name = lowcase(folder);
            put 'ERROR- Try to use: ' lowcase_name;
            put;
          end;
        _abort_ + 1;
      end;

    /* ignore unknown types for folders */
    if not (upcase(type) in: 
      ('LIBNAME' 'MACRO' /*'MACROS'*/ 'DATA' 
      'FUNCTION' /*'FUNCTIONS'*/ 'FORMAT' /*'FORMATS'*/ 
      'IMLMODULE' 'PROTO' 'EXEC' 'CLEAN' 
      'LAZYDATA' 'TEST' 'CASLUDF'
      'ADDCNT' 'KMFSNIP'
      'DS2PCK' 'DS2THR'
      )) 
    then 
      do;
        if first.folder = 1 then 
          do;
            put "WARNING: Type " type 'is not yet supported.' /
              "WARNING- Folder " folder " will be ignored. " /
              "WARNING- No content from it will be used to generate the package." / " ";
          end;
        delete;
      end;

    /* ...but! do not use files from "additional content" directory */
    if NOT (upcase(type) =: 'ADDCNT') then
      do ;
        if file NE lowcase(file) then
          do;
            put 'ERROR: File with code should be named ONLY with low case letters.';
            put 'ERROR- Current value is: ' file;
            lowcase_name = lowcase(file);
            put 'ERROR- Try to use: ' lowcase_name;
            put;
            _abort_ + 1;
          end;
        if ext = "sas" then output; /* ignore not ".sas" files */
        else
          do;
            put "WARNING: Only *.sas files are supported." /
                "WARNING- The file: " file "will be ignored." /
                "WARNING- ";
          end;
      end;
    else
      do;
        file = "additionalcontent";
        fileshort = file;
        additionalContent+first.folder;
        if first.folder =1 then
          do;
            if additionalContent > 1 then
              do;
                put "WARNING: Only ONE directory with additional content is allowed!" /
                    "WARNING- Store all additional content in a single directory." /
                    "WARNING- The directory: " folder "will be ignored." /
                    "WARNING- ";
              end;
            else
              do;
                /*output;*/
                put "NOTE: Additional content located in " folder;
                call symputX('additionalContent', folder);
              end;
          end;
      end;

    if _abort_ then
    do;
      put 'ERROR: Aborting due to previous errors.';
      abort;
    end;
  run ;

  proc sort data=&filesWithCodes.;
    by group name ;
  run;

%mend _collectFilesWithCodes;

/* ------------------------------------------------------------------------------------ */

%macro _generateWorkflows(repoLocation   =
                        , branch         = main
                        , relDocLocation = docs
                        , wfLocation     =
);
  
  %let wfref = _%sysfunc(datetime(), hex6.)w ;
  %if %superq(wfLocation) eq %then
  /* Output to .github/workflows */
    %do ;
      libname &wfref. "&repoLocation./.github";
      libname &wfref. clear;
      libname &wfref. "&repoLocation./.github/workflows";
      libname &wfref. clear;
      filename &wfref. "&repoLocation./.github/workflows/deploy.yml";
    %end ;
  %else
    filename &wfref. "&wfLocation./deploy.yml"; ;


  %put NOTE: Ensure your GitHub Pages settings for this repository are set to deploy with **GitHub Actions**.;

  data _null_ ;
    file &wfref. ;
    
    put "name: Docs (Jupyter Book/Sphinx) GitHub Pages Deploy" ;
    put "on:" ;
    put "  push:" ;
    put "    branches: [&branch.]" ;
    put "  workflow_dispatch:" ;
    put "    inputs:" ;
    put "      builder:" ;
    put "        description: 'Docs builder to use (auto, jupyterbook, sphinx)'" ;
    put "        required: false" ;
    put "        default: 'auto'" ;
    put "env:" ;
    put "  BASE_URL: /${{ github.event.repository.name }}" ;
    put " " ;
    put "permissions:" ;
    put "  contents: read" ;
    put "  pages: write" ;
    put "  id-token: write" ;
    put "concurrency:" ;
    put "  group: 'pages'" ;
    put "  cancel-in-progress: false" ;
    put "jobs:" ;
    put "  deploy:" ;
    put "    environment:" ;
    put "      name: github-pages" ;
    put "      url: ${{ steps.deployment.outputs.page_url }}" ;
    put "    runs-on: ubuntu-latest" ;
    put "    steps:" ;
    put "      - uses: actions/checkout@v4" ;
    put "      - name: Setup Pages" ;
    put "        uses: actions/configure-pages@v3" ;
    put "      - name: Setup Python" ;
    put "        uses: actions/setup-python@v5" ;
    put "        with:" ;
    put "          python-version: '3.11'" ;
    put "      - uses: actions/setup-node@v4" ;
    put "        with:" ;
    put "          node-version: '18.x'" ;
    put "      - name: Detect docs builder" ;
    put "        id: detect" ;
    put "        run: |" ;
    put "          set -euo pipefail" ;
    put '          builder_input="${{ inputs.builder ||' "'auto'" '}}"' ;
    put '          if [[ "$builder_input" != "auto" ]]; then' ;
    put '            echo "builder=$builder_input" >> "$GITHUB_OUTPUT"' ;
    put "            exit 0" ;
    put "          fi" ;
    put " " ;
    put '          if [[ -f "docs/myst.yml" ]]; then' ;
    put '            echo "builder=jupyterbook" >> "$GITHUB_OUTPUT"' ;
    put "            exit 0" ;
    put "          fi" ;
    put " " ;
    put "          if [[ -f 'docs/conf.py' ]]; then" ;
    put '            echo "builder=sphinx" >> "$GITHUB_OUTPUT"' ;
    put "            exit 0" ;
    put "          fi" ;
    put " " ;
    put '          echo "No docs/myst.yml or docs/conf.py found. Please add one or select a builder." >&2' ;
    put "          exit 1" ;
    put "      - name: Install Jupyter Book (via myst)" ;
    put "        if: steps.detect.outputs.builder == 'jupyterbook'" ;
    put "        run: npm install -g jupyter-book" ;
    put "      - name: Install Sphinx" ;
    put "        if: steps.detect.outputs.builder == 'sphinx' " ;
    put "        run: python -m pip install --upgrade pip sphinx myst-parser sphinx-book-theme sphinx-rtd-theme" ;
    put "      - name: Build HTML Assets (Jupyter Book)" ;
    put "        if: steps.detect.outputs.builder == 'jupyterbook'" ;
    put "        run: jupyter-book build --html" ;
    put "        working-directory: &relDocLocation." ;
    put "      - name: Build HTML Assets (Sphinx)" ;
    put "        if: steps.detect.outputs.builder == 'sphinx'" ;
    put "        run: sphinx-build -b html &relDocLocation. &relDocLocation./_build/html" ;
    put "      - name: Upload artifact" ;
    put "        uses: actions/upload-pages-artifact@v3" ;
    put "        with:" ;
    put "          path: './&relDocLocation./_build/html'" ;
    put "      - name: Deploy to GitHub Pages" ;
    put "        id: deployment" ;
    put "        uses: actions/deploy-pages@v4" ;
  run ;

  filename &wfref. clear;

%mend _generateWorkflows;